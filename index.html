<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>精度改善版：スマートフォン姿勢判定</title>
  <style>
    :root { --w: 240px; --h: 320px; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, "Helvetica Neue", Arial, "Noto Sans JP";
      font-size: 18px;
      margin: 0;
      color: #111;
      background: #fafafa;
    }
    header {
      padding: 12px 16px;
      background: #fff;
      border-bottom: 1px solid #eee;
      position: sticky;
      top: 0;
      z-index: 10;
    }
    h1 { font-size: 20px; margin: 0; }
    main {
      display: grid;
      grid-template-columns: 1fr;
      gap: 12px;
      padding: 12px;
      place-items: center;
    }
    .stage {
      display: flex;
      flex-direction: column;
      gap: 8px;
      align-items: center;
    }
    .pair {
      display: flex;
      gap: 8px;
      align-items: center;
      justify-content: center;
      flex-direction: row;
    }
    video, canvas {
      transform: scaleX(-1);
      width: var(--w);
      height: var(--h);
      border: 1px solid #ddd;
      background: #000;
      border-radius: 6px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
    }
    button {
      font-size: 15px;
      padding: 8px 14px;
      border-radius: 10px;
      border: 1px solid #ccc;
      background: #fff;
      cursor: pointer;
    }
    button.primary {
      background: #0ea5e9;
      color: #fff;
      border-color: #0ea5e9;
    }
    button:disabled { opacity: .6; cursor: not-allowed; }
    .panel {
      width: min(680px, 92vw);
      background: #fff;
      border: 1px solid #eee;
      border-radius: 12px;
      padding: 12px;
    }
    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
      white-space: pre-line;
    }
    #warning {
      font-size: 24px;
      font-weight: 800;
      text-align: center;
      margin: 4px 0 0;
    }
    .ok { color: #16a34a; }
    .bad { color: #dc2626; }
    .hint { color: #666; font-size: 13px; }
    .badge {
      display:inline-block;
      padding:2px 8px;
      border-radius:999px;
      background:#f1f5f9;
      font-size:12px;
    }
    @media (max-width: 760px) {
      .pair { flex-direction: column; flex-wrap: nowrap; }
    }
    #canvas { display: none; }
    .confidence-bar {
      width: 100%;
      height: 20px;
      background: #eee;
      border-radius: 4px;
      overflow: hidden;
      margin: 8px 0;
    }
    .confidence-fill {
      height: 100%;
      background: linear-gradient(90deg, #16a34a, #eab308, #dc2626);
      transition: width 0.3s;
    }
  </style>
</head>
<body>
  <header>
    <h1>精度改善版：姿勢判定 <span class="badge">v4.0</span></h1>
  </header>

  <main>
    <section class="stage">
      <div class="controls">
        <button id="startBtn" class="primary">測定開始</button>
        <button id="calibBtn" disabled>正しい姿勢の基準</button>
        <button id="resetBtn" disabled>解除</button>
      </div>
      <div class="pair">
        <video id="video" autoplay muted playsinline></video>
        <canvas id="canvas"></canvas>
      </div>
    </section>

    <section class="panel">
      <div id="warning" class="ok">測定待機中</div>
      <div>
        <div style="font-size: 14px; color: #666; margin-bottom: 4px;">姿勢悪化度</div>
        <div class="confidence-bar">
          <div id="confidenceBar" class="confidence-fill" style="width: 0%"></div>
        </div>
      </div>
      <div class="row">
        <div>
          <h3>現在値</h3>
          <div id="output" class="mono">読み取り中...</div>
        </div>
      </div>
      <p class="hint">
        <strong>改善点:</strong><br>
        ✓ 移動平均フィルタで安定性向上<br>
        ✓ 個人差に対応した適応的閾値<br>
        ✓ 複合スコアによる総合判定<br>
        ✓ ヒステリシス機能で誤判定防止<br>
        ✓ 信頼度ベースの警告制御
      </p>

      <div class="controls" style="margin-top:6px">
        <button id="logStartBtn">ログ開始</button>
        <button id="logStopBtn" disabled>ログ停止</button>
        <button id="exportCsvBtn">CSVエクスポート</button>
        <button id="clearLogBtn">ログ全削除</button>
      </div>
    </section>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    // ========== 改善された設定 ==========
    const PARAMS = {
      // 移動平均のウィンドウサイズ
      movingAvgWindow: 10,
      
      // 適応的閾値の学習率
      adaptiveLearningRate: 0.01,
      
      // 判定のための複合スコア閾値
      badPostureThreshold: 0.65,
      goodPostureThreshold: 0.35,
      
      // 警告表示の持続時間 (ms)
      sustainMs: 2000,
      clearMs: 1000,
      
      // 警告音設定
      beep: { intervalMs: 500, freq: 880, dur: 0.3, gain: 0.08 }
    };

    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const output = document.getElementById('output');
    const warning = document.getElementById('warning');
    const confidenceBar = document.getElementById('confidenceBar');
    const startBtn = document.getElementById('startBtn');
    const calibBtn = document.getElementById('calibBtn');
    const resetBtn = document.getElementById('resetBtn');

    // ========== データ構造 ==========
    class MovingAverage {
      constructor(size) {
        this.size = size;
        this.values = [];
      }
      
      add(value) {
        this.values.push(value);
        if (this.values.length > this.size) {
          this.values.shift();
        }
      }
      
      get() {
        if (this.values.length === 0) return null;
        return this.values.reduce((a, b) => a + b) / this.values.length;
      }
      
      getStd() {
        const avg = this.get();
        if (!avg) return 0;
        const squareDiffs = this.values.map(v => Math.pow(v - avg, 2));
        return Math.sqrt(squareDiffs.reduce((a, b) => a + b) / this.values.length);
      }
    }

    // 移動平均バッファ
    const yDiffBuffer = new MovingAverage(PARAMS.movingAvgWindow);
    const noseZBuffer = new MovingAverage(PARAMS.movingAvgWindow);
    const pitchBuffer = new MovingAverage(PARAMS.movingAvgWindow);

    // 基準値
    let baselineYdiff = null;
    let baselineNoseZ = null;
    let baselinePitch = null;

    // 適応的閾値
    let adaptiveThresholds = {
      yDiffRange: 0.1,
      noseZRange: 0.05,
      pitchRange: 20
    };

    // 状態管理
    let rawPitch = 0, rawRoll = 0;
    let bentState = false;
    let enterStart = null, exitStart = null;
    let camera = null;
    let lastInferenceTs = 0;
    let faceDetected = false;

    // キャリブレーション
    let calibMode = false;
    let calibSamples = [];
    let calibStartTs = 0;

    // 音声
    let audioCtx = null;
    let beepInterval = null;

    // ========== 音声機能 ==========
    function ensureAudio() {
      try {
        if (!audioCtx) {
          audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        }
        if (audioCtx.state === 'suspended') {
          audioCtx.resume?.();
        }
      } catch (e) {
        console.warn('AudioContext初期化に失敗:', e);
        audioCtx = null;
      }
    }

    function playBeep() {
      if (!audioCtx) return;
      const { freq, dur, gain } = PARAMS.beep;
      const osc = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      osc.type = 'sine';
      osc.frequency.setValueAtTime(freq, audioCtx.currentTime);
      g.gain.setValueAtTime(gain, audioCtx.currentTime);
      osc.connect(g).connect(audioCtx.destination);
      osc.start();
      osc.stop(audioCtx.currentTime + dur);
      osc.onended = () => { try { osc.disconnect(); g.disconnect(); } catch {} };
    }

    function startBeepLoop() {
      if (beepInterval) return;
      playBeep();
      beepInterval = setInterval(playBeep, PARAMS.beep.intervalMs);
    }

    function stopBeepLoop() {
      if (beepInterval) { clearInterval(beepInterval); beepInterval = null; }
    }

    // ========== センサー ==========
    function handleOrientation(e) {
      rawPitch = e.beta ?? 0;
      rawRoll = e.gamma ?? 0;
      pitchBuffer.add(rawPitch);
    }

    // ========== 改善された姿勢判定 ==========
    function calculatePostureScore(yDiff, noseZ, pitch) {
      // 基準値がない場合はスコア計算不可
      if (!baselineYdiff || !baselineNoseZ || baselinePitch === null) {
        return 0.5; // 中立
      }

      // 各指標の偏差を正規化
      const yDiffDeviation = Math.abs(yDiff - baselineYdiff) / adaptiveThresholds.yDiffRange;
      const noseZDeviation = Math.abs(noseZ - baselineNoseZ) / adaptiveThresholds.noseZRange;
      const pitchDeviation = Math.abs(pitch - baselinePitch) / adaptiveThresholds.pitchRange;

      // 下向き姿勢の場合はペナルティ
      const downwardPenalty = (yDiff - baselineYdiff) < -0.03 ? 0.3 : 0;
      const closePenalty = (noseZ - baselineNoseZ) < -0.02 ? 0.2 : 0;
      
      // 複合スコア計算 (0=良い姿勢, 1=悪い姿勢)
      let score = (yDiffDeviation * 0.4 + noseZDeviation * 0.3 + pitchDeviation * 0.3);
      score += downwardPenalty + closePenalty;
      
      // 0-1の範囲にクリップ
      return Math.max(0, Math.min(1, score));
    }

    function updateAdaptiveThresholds(yDiff, noseZ, pitch) {
      const yStd = yDiffBuffer.getStd();
      const zStd = noseZBuffer.getStd();
      const pStd = pitchBuffer.getStd();

      adaptiveThresholds.yDiffRange = Math.max(0.05, yStd * 2);
      adaptiveThresholds.noseZRange = Math.max(0.03, zStd * 2);
      adaptiveThresholds.pitchRange = Math.max(10, pStd * 2);
    }

    // ========== FaceMesh ==========
    const faceMesh = new FaceMesh({ 
      locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}` 
    });
    faceMesh.setOptions({ 
      maxNumFaces: 1, 
      refineLandmarks: false, 
      minDetectionConfidence: 0.5, 
      minTrackingConfidence: 0.5 
    });

    faceMesh.onResults(results => {
      const now = performance.now();
      if (now - lastInferenceTs < 100) return;
      lastInferenceTs = now;

      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

      if (!results.multiFaceLandmarks || results.multiFaceLandmarks.length === 0) {
        faceDetected = false;
        setWarning(true, '顔が検出できません');
        output.textContent = '顔が見つかりません';
        return;
      }
      
      faceDetected = true;
      const lm = results.multiFaceLandmarks[0];
      const nose = lm[1];
      const chin = lm[152];

      drawPoint(nose, '#22c55e');
      drawPoint(chin, '#2563eb');

      const yDiff = chin.y - nose.y;
      const noseZ = nose.z;
      const pitch = pitchBuffer.get() || 0;

      // 移動平均に追加
      yDiffBuffer.add(yDiff);
      noseZBuffer.add(noseZ);

      const smoothYdiff = yDiffBuffer.get();
      const smoothNoseZ = noseZBuffer.get();

      // キャリブレーションモード
      if (calibMode) {
        calibSamples.push({ y: smoothYdiff, z: smoothNoseZ, p: pitch });

        if (now - calibStartTs >= 3000) {
          calibMode = false;
          if (calibSamples.length > 0) {
            const sum = calibSamples.reduce((acc, v) => {
              acc.y += v.y;
              acc.z += v.z;
              acc.p += v.p;
              return acc;
            }, { y: 0, z: 0, p: 0 });
            const n = calibSamples.length;
            baselineYdiff = sum.y / n;
            baselineNoseZ = sum.z / n;
            baselinePitch = sum.p / n;
            
            saveCalibration(baselineYdiff, baselineNoseZ, baselinePitch);
            setWarning(false, 'ニュートラルを登録しました');
          }
        }

        if (calibMode) {
          output.textContent = `キャリブレーション中...\n残り: ${Math.ceil((3000 - (now - calibStartTs)) / 1000)}秒`;
          return;
        }
      }

      // 適応的閾値の更新
      updateAdaptiveThresholds(smoothYdiff, smoothNoseZ, pitch);

      // 姿勢スコア計算
      const postureScore = calculatePostureScore(smoothYdiff, smoothNoseZ, pitch);
      
      // 信頼度バーの更新
      confidenceBar.style.width = `${postureScore * 100}%`;

      // ヒステリシス判定
      const isBadNow = postureScore > PARAMS.badPostureThreshold;
      updateSustain(isBadNow);

      // デバッグ出力
      output.textContent =
        `Pitch: ${pitch.toFixed(2)}°\n` +
        `yDiff: ${smoothYdiff?.toFixed(4) || 'N/A'}\n` +
        `noseZ: ${smoothNoseZ?.toFixed(4) || 'N/A'}\n` +
        `姿勢スコア: ${(postureScore * 100).toFixed(1)}%\n` +
        `基準値: ${baselineYdiff ? '設定済み' : '未設定'}\n` +
        `適応範囲: Y±${adaptiveThresholds.yDiffRange.toFixed(3)}`;

      addLogSample();
    });

    function drawPoint(normLandmark, color) {
      const x = normLandmark.x * canvas.width;
      const y = normLandmark.y * canvas.height;
      ctx.beginPath();
      ctx.arc(x, y, 4, 0, Math.PI * 2);
      ctx.fillStyle = color;
      ctx.fill();
    }

    function updateSustain(isNow) {
      if (calibMode) {
        bentState = false;
        enterStart = exitStart = null;
        stopBeepLoop();
        setWarning(false, 'キャリブレーション中: 良い姿勢で3秒間静止してください');
        return;
      }

      const t = performance.now();
      if (isNow) {
        if (enterStart == null) enterStart = t;
        exitStart = null;
        const elapsed = t - enterStart;
        if (!bentState && elapsed >= PARAMS.sustainMs) {
          bentState = true;
          setWarning(true, '首が曲がっています');
          startBeepLoop();
        }
      } else {
        if (exitStart == null) exitStart = t;
        enterStart = null;
        const elapsed = t - exitStart;
        if (bentState && elapsed >= PARAMS.clearMs) {
          bentState = false;
          setWarning(false, '首は曲がっていません');
          stopBeepLoop();
        }
      }

      if (faceDetected) {
        setWarning(bentState, bentState ? '首が曲がっています' : '首は曲がっていません');
      }
    }

    let lastWarnText = null, lastWarnBad = null;
    function setWarning(bad, text) {
      if (text === lastWarnText && bad === lastWarnBad) return;
      lastWarnText = text;
      lastWarnBad = bad;
      warning.textContent = text;
      warning.className = bad ? 'bad' : 'ok';
    }

    async function initCamera() {
      const stream = await navigator.mediaDevices.getUserMedia({
        video: { facingMode: 'user', width: {ideal: 640}, height: {ideal: 480} },
        audio: false
      });
      video.srcObject = stream;
      await new Promise(r => video.onloadedmetadata = r);
      canvas.width = video.videoWidth;
      canvas.height = video.videoHeight;
    }

    async function startAll() {
      if (typeof DeviceOrientationEvent !== 'undefined' && 
          typeof DeviceOrientationEvent.requestPermission === 'function') {
        try {
          const res = await DeviceOrientationEvent.requestPermission();
          if (res === 'granted') {
            window.addEventListener('deviceorientation', handleOrientation);
          } else {
            output.textContent = 'センサーの利用が許可されませんでした。';
            return;
          }
        } catch {
          output.textContent = 'センサー許可でエラーが発生しました。';
          return;
        }
      } else {
        window.addEventListener('deviceorientation', handleOrientation);
      }

      await initCamera();

      bentState = false;
      enterStart = exitStart = null;
      stopBeepLoop();
      
      calibMode = false;
      calibSamples = [];
      calibStartTs = 0;

      ensureAudio();

      camera = new Camera(video, {
        onFrame: async () => {
          const t = performance.now();
          if (t - lastInferenceTs >= 100) {
            await faceMesh.send({ image: video });
          }
        },
        width: 640,
        height: 480
      });
      camera.start();

      startBtn.disabled = true;
      calibBtn.disabled = false;
      resetBtn.disabled = false;

      const saved = loadCalibration();
      if (saved) {
        baselineYdiff = saved.y;
        baselineNoseZ = saved.z;
        baselinePitch = saved.p;
        setWarning(false, '測定中...');
      } else {
        setWarning(false, '測定中... (基準姿勢を登録してください)');
      }
    }

    function calibrate() {
      if (!yDiffBuffer.get() || !noseZBuffer.get()) {
        setWarning(true, 'まだ値が安定していません。数秒待ってからもう一度試してください');
        return;
      }
      calibMode = true;
      calibSamples = [];
      calibStartTs = performance.now();
      setWarning(false, '良い姿勢で3秒間そのまま静止してください');
    }

    function resetCalibration() {
      baselineYdiff = null;
      baselineNoseZ = null;
      baselinePitch = null;
      calibMode = false;
      calibSamples = [];
      calibStartTs = 0;
      localStorage.removeItem('posture-calib-v4');
      setWarning(false, 'キャリブを解除しました');
    }

    function saveCalibration(y, z, p) {
      try {
        localStorage.setItem('posture-calib-v4', JSON.stringify({ y, z, p }));
      } catch {}
    }

    function loadCalibration() {
      try {
        return JSON.parse(localStorage.getItem('posture-calib-v4'));
      } catch {
        return null;
      }
    }

    // ========== ログ機能 (簡略版) ==========
    const DB_NAME = 'posture-db-v4';
    const STORE = 'logs';
    let db = null;
    let LOGGING = false;
    let logBuffer = [];
    let lastLogAt = 0;

    function openDB() {
      return new Promise((resolve, reject) => {
        const req = indexedDB.open(DB_NAME, 1);
        req.onupgradeneeded = (e) => {
          const _db = e.target.result;
          if (!_db.objectStoreNames.contains(STORE)) {
            _db.createObjectStore(STORE, { keyPath: 'ts' });
          }
        };
        req.onsuccess = () => { db = req.result; resolve(db); };
        req.onerror = () => reject(req.error);
      });
    }

    async function addLogSample() {
      if (!LOGGING) return;
      const now = performance.now();
      if (now - lastLogAt < 1000) return;
      lastLogAt = now;

      const ts = Date.now();
      logBuffer.push({
        ts,
        pitch: pitchBuffer.get(),
        yDiff: yDiffBuffer.get(),
        noseZ: noseZBuffer.get(),
        score: calculatePostureScore(yDiffBuffer.get(), noseZBuffer.get(), pitchBuffer.get()),
        bent: bentState
      });

      if (logBuffer.length >= 5) {
        await flushLogs();
      }
    }

    async function flushLogs() {
      if (!db || logBuffer.length === 0) return;
      const tx = db.transaction(STORE, 'readwrite');
      const store = tx.objectStore(STORE);
      for (const e of logBuffer) store.put(e);
      await new Promise((res, rej) => { 
        tx.oncomplete = res; 
        tx.onerror = () => rej(tx.error); 
      });
      logBuffer = [];
    }

    async function exportCSV() {
      await flushLogs();
      if (!db) await openDB();

      const tx = db.transaction(STORE, 'readonly');
      const store = tx.objectStore(STORE);
      const rows = [['timestamp','pitch','yDiff','noseZ','postureScore','bent']];
      const req = store.openCursor();
      
      await new Promise((resolve, reject) => {
        req.onsuccess = (e) => {
          const cur = e.target.result;
          if (!cur) return resolve();
          const v = cur.value;
          rows.push([
            v.ts,
            v.pitch?.toFixed?.(3) || '',
            v.yDiff?.toFixed?.(5) || '',
            v.noseZ?.toFixed?.(5) || '',
            v.score?.toFixed?.(3) || '',
            v.bent ? 1 : 0
          ]);
          cur.continue();
        };
        req.onerror = () => reject(req.error);
      });

      const csv = rows.map(r => r.join(',')).join('\n');
      const blob = new Blob([csv], {type:'text/csv'});
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `posture_improved_${Date.now()}.csv`;
      document.body.appendChild(a);
      a.click();
      a.remove();
      URL.revokeObjectURL(url);
    }

    async function clearAllLogs() {
      if (!db) await openDB();
      await flushLogs();
      const tx = db.transaction(STORE, 'readwrite');
      tx.objectStore(STORE).clear();
      await new Promise((res, rej) => { 
        tx.oncomplete = res; 
        tx.onerror = () => rej(tx.error); 
      });
      setWarning(false, 'ログを全削除しました');
    }

    // ========== UI配線 ==========
    window.addEventListener('load', async () => {
      await openDB();

      startBtn.addEventListener('click', startAll);
      calibBtn.addEventListener('click', calibrate);
      resetBtn.addEventListener('click', resetCalibration);

      const logStartBtn = document.getElementById('logStartBtn');
      const logStopBtn = document.getElementById('logStopBtn');
      const exportCsvBtn = document.getElementById('exportCsvBtn');
      const clearLogBtn = document.getElementById('clearLogBtn');

      if (logStartBtn) logStartBtn.addEventListener('click', async () => {
        LOGGING = true;
        lastLogAt = 0;
        logStartBtn.disabled = true;
        logStopBtn.disabled = false;
      });

      if (logStopBtn) logStopBtn.addEventListener('click', async () => {
        LOGGING = false;
        await flushLogs();
        logStartBtn.disabled = false;
        logStopBtn.disabled = true;
      });

      if (exportCsvBtn) exportCsvBtn.addEventListener('click', exportCSV);
      if (clearLogBtn) clearLogBtn.addEventListener('click', clearAllLogs);
    });
  </script>
</body>
</html>
